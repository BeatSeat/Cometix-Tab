// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file fs.proto (package aiserver.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { FilesyncUpdateWithModelVersion } from "./cpp_pb.js";

/**
 * @version: 1.3.6~1.3.7
 * @author: wisdgod <nav@wisdgod.com>
 * @license: MIT OR Apache-2.0
 * SimpleRange is defined in cpp.proto
 *
 * aiserver.v1.FSUploadErrorType
 *
 * @generated from enum aiserver.v1.FSUploadErrorType
 */
export enum FSUploadErrorType {
  /**
   * @generated from enum value: FS_UPLOAD_ERROR_TYPE_UNSPECIFIED = 0;
   */
  FS_UPLOAD_ERROR_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: FS_UPLOAD_ERROR_TYPE_NON_EXISTANT = 1;
   */
  FS_UPLOAD_ERROR_TYPE_NON_EXISTANT = 1,

  /**
   * @generated from enum value: FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH = 2;
   */
  FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FSUploadErrorType)
proto3.util.setEnumType(FSUploadErrorType, "aiserver.v1.FSUploadErrorType", [
  { no: 0, name: "FS_UPLOAD_ERROR_TYPE_UNSPECIFIED" },
  { no: 1, name: "FS_UPLOAD_ERROR_TYPE_NON_EXISTANT" },
  { no: 2, name: "FS_UPLOAD_ERROR_TYPE_HASH_MISMATCH" },
]);

/**
 * aiserver.v1.FSSyncErrorType
 *
 * @generated from enum aiserver.v1.FSSyncErrorType
 */
export enum FSSyncErrorType {
  /**
   * @generated from enum value: FS_SYNC_ERROR_TYPE_UNSPECIFIED = 0;
   */
  FS_SYNC_ERROR_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: FS_SYNC_ERROR_TYPE_NON_EXISTANT = 1;
   */
  FS_SYNC_ERROR_TYPE_NON_EXISTANT = 1,

  /**
   * @generated from enum value: FS_SYNC_ERROR_TYPE_HASH_MISMATCH = 2;
   */
  FS_SYNC_ERROR_TYPE_HASH_MISMATCH = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FSSyncErrorType)
proto3.util.setEnumType(FSSyncErrorType, "aiserver.v1.FSSyncErrorType", [
  { no: 0, name: "FS_SYNC_ERROR_TYPE_UNSPECIFIED" },
  { no: 1, name: "FS_SYNC_ERROR_TYPE_NON_EXISTANT" },
  { no: 2, name: "FS_SYNC_ERROR_TYPE_HASH_MISMATCH" },
]);

/**
 * aiserver.v1.FSUploadFileRequest
 *
 * @generated from message aiserver.v1.FSUploadFileRequest
 */
export class FSUploadFileRequest extends Message<FSUploadFileRequest> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * @generated from field: string relative_workspace_path = 2;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string contents = 3;
   */
  contents = "";

  /**
   * @generated from field: int32 model_version = 4;
   */
  modelVersion = 0;

  /**
   * @generated from field: optional string sha256_hash = 5;
   */
  sha256Hash?: string;

  constructor(data?: PartialMessage<FSUploadFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSUploadFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "model_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "sha256_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSUploadFileRequest {
    return new FSUploadFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSUploadFileRequest {
    return new FSUploadFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSUploadFileRequest {
    return new FSUploadFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSUploadFileRequest | PlainMessage<FSUploadFileRequest> | undefined, b: FSUploadFileRequest | PlainMessage<FSUploadFileRequest> | undefined): boolean {
    return proto3.util.equals(FSUploadFileRequest, a, b);
  }
}

/**
 * aiserver.v1.FSUploadFileResponse
 *
 * @generated from message aiserver.v1.FSUploadFileResponse
 */
export class FSUploadFileResponse extends Message<FSUploadFileResponse> {
  /**
   * @generated from field: aiserver.v1.FSUploadErrorType error = 1;
   */
  error = FSUploadErrorType.FS_UPLOAD_ERROR_TYPE_UNSPECIFIED;

  constructor(data?: PartialMessage<FSUploadFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSUploadFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "enum", T: proto3.getEnumType(FSUploadErrorType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSUploadFileResponse {
    return new FSUploadFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSUploadFileResponse {
    return new FSUploadFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSUploadFileResponse {
    return new FSUploadFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSUploadFileResponse | PlainMessage<FSUploadFileResponse> | undefined, b: FSUploadFileResponse | PlainMessage<FSUploadFileResponse> | undefined): boolean {
    return proto3.util.equals(FSUploadFileResponse, a, b);
  }
}

/**
 * FilesyncUpdateWithModelVersion and SingleUpdateRequest are defined in cpp.proto
 *
 * aiserver.v1.FSSyncFileRequest
 *
 * @generated from message aiserver.v1.FSSyncFileRequest
 */
export class FSSyncFileRequest extends Message<FSSyncFileRequest> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * @generated from field: string relative_workspace_path = 2;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: int32 model_version = 3;
   */
  modelVersion = 0;

  /**
   * @generated from field: repeated aiserver.v1.FilesyncUpdateWithModelVersion filesync_updates = 4;
   */
  filesyncUpdates: FilesyncUpdateWithModelVersion[] = [];

  /**
   * @generated from field: string sha256_hash = 5;
   */
  sha256Hash = "";

  constructor(data?: PartialMessage<FSSyncFileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSSyncFileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "model_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "filesync_updates", kind: "message", T: FilesyncUpdateWithModelVersion, repeated: true },
    { no: 5, name: "sha256_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSSyncFileRequest {
    return new FSSyncFileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSSyncFileRequest {
    return new FSSyncFileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSSyncFileRequest {
    return new FSSyncFileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSSyncFileRequest | PlainMessage<FSSyncFileRequest> | undefined, b: FSSyncFileRequest | PlainMessage<FSSyncFileRequest> | undefined): boolean {
    return proto3.util.equals(FSSyncFileRequest, a, b);
  }
}

/**
 * aiserver.v1.FSSyncFileResponse
 *
 * @generated from message aiserver.v1.FSSyncFileResponse
 */
export class FSSyncFileResponse extends Message<FSSyncFileResponse> {
  /**
   * @generated from field: aiserver.v1.FSSyncErrorType error = 1;
   */
  error = FSSyncErrorType.FS_SYNC_ERROR_TYPE_UNSPECIFIED;

  constructor(data?: PartialMessage<FSSyncFileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSSyncFileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "enum", T: proto3.getEnumType(FSSyncErrorType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSSyncFileResponse {
    return new FSSyncFileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSSyncFileResponse {
    return new FSSyncFileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSSyncFileResponse {
    return new FSSyncFileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSSyncFileResponse | PlainMessage<FSSyncFileResponse> | undefined, b: FSSyncFileResponse | PlainMessage<FSSyncFileResponse> | undefined): boolean {
    return proto3.util.equals(FSSyncFileResponse, a, b);
  }
}

/**
 * aiserver.v1.FSIsEnabledForUserRequest
 *
 * @generated from message aiserver.v1.FSIsEnabledForUserRequest
 */
export class FSIsEnabledForUserRequest extends Message<FSIsEnabledForUserRequest> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  constructor(data?: PartialMessage<FSIsEnabledForUserRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSIsEnabledForUserRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSIsEnabledForUserRequest {
    return new FSIsEnabledForUserRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSIsEnabledForUserRequest {
    return new FSIsEnabledForUserRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSIsEnabledForUserRequest {
    return new FSIsEnabledForUserRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSIsEnabledForUserRequest | PlainMessage<FSIsEnabledForUserRequest> | undefined, b: FSIsEnabledForUserRequest | PlainMessage<FSIsEnabledForUserRequest> | undefined): boolean {
    return proto3.util.equals(FSIsEnabledForUserRequest, a, b);
  }
}

/**
 * aiserver.v1.FSIsEnabledForUserResponse
 *
 * @generated from message aiserver.v1.FSIsEnabledForUserResponse
 */
export class FSIsEnabledForUserResponse extends Message<FSIsEnabledForUserResponse> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<FSIsEnabledForUserResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSIsEnabledForUserResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSIsEnabledForUserResponse {
    return new FSIsEnabledForUserResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSIsEnabledForUserResponse {
    return new FSIsEnabledForUserResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSIsEnabledForUserResponse {
    return new FSIsEnabledForUserResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSIsEnabledForUserResponse | PlainMessage<FSIsEnabledForUserResponse> | undefined, b: FSIsEnabledForUserResponse | PlainMessage<FSIsEnabledForUserResponse> | undefined): boolean {
    return proto3.util.equals(FSIsEnabledForUserResponse, a, b);
  }
}

/**
 * aiserver.v1.FSGetFileContentsRequest
 *
 * @generated from message aiserver.v1.FSGetFileContentsRequest
 */
export class FSGetFileContentsRequest extends Message<FSGetFileContentsRequest> {
  /**
   * @generated from field: string uuid = 1;
   */
  uuid = "";

  /**
   * @generated from field: string auth_id = 2;
   */
  authId = "";

  /**
   * @generated from field: string relative_workspace_path = 3;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: int32 model_version = 4;
   */
  modelVersion = 0;

  /**
   * @generated from field: repeated aiserver.v1.FilesyncUpdateWithModelVersion filesync_updates = 5;
   */
  filesyncUpdates: FilesyncUpdateWithModelVersion[] = [];

  /**
   * @generated from field: optional string sha256_hash = 6;
   */
  sha256Hash?: string;

  constructor(data?: PartialMessage<FSGetFileContentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSGetFileContentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "auth_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "model_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "filesync_updates", kind: "message", T: FilesyncUpdateWithModelVersion, repeated: true },
    { no: 6, name: "sha256_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSGetFileContentsRequest {
    return new FSGetFileContentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSGetFileContentsRequest {
    return new FSGetFileContentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSGetFileContentsRequest {
    return new FSGetFileContentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSGetFileContentsRequest | PlainMessage<FSGetFileContentsRequest> | undefined, b: FSGetFileContentsRequest | PlainMessage<FSGetFileContentsRequest> | undefined): boolean {
    return proto3.util.equals(FSGetFileContentsRequest, a, b);
  }
}

/**
 * aiserver.v1.FSGetFileContentsResponse
 *
 * @generated from message aiserver.v1.FSGetFileContentsResponse
 */
export class FSGetFileContentsResponse extends Message<FSGetFileContentsResponse> {
  /**
   * @generated from field: string contents = 1;
   */
  contents = "";

  /**
   * @generated from field: optional string sha256_hash = 2;
   */
  sha256Hash?: string;

  constructor(data?: PartialMessage<FSGetFileContentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSGetFileContentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sha256_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSGetFileContentsResponse {
    return new FSGetFileContentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSGetFileContentsResponse {
    return new FSGetFileContentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSGetFileContentsResponse {
    return new FSGetFileContentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSGetFileContentsResponse | PlainMessage<FSGetFileContentsResponse> | undefined, b: FSGetFileContentsResponse | PlainMessage<FSGetFileContentsResponse> | undefined): boolean {
    return proto3.util.equals(FSGetFileContentsResponse, a, b);
  }
}

/**
 * aiserver.v1.FileRequest
 *
 * @generated from message aiserver.v1.FileRequest
 */
export class FileRequest extends Message<FileRequest> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: optional int32 requested_version = 2;
   */
  requestedVersion?: number;

  /**
   * @generated from field: optional string sha256_hash = 3;
   */
  sha256Hash?: string;

  /**
   * @generated from field: bool required = 4;
   */
  required = false;

  constructor(data?: PartialMessage<FileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "requested_version", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "sha256_hash", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileRequest {
    return new FileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileRequest {
    return new FileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileRequest {
    return new FileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FileRequest | PlainMessage<FileRequest> | undefined, b: FileRequest | PlainMessage<FileRequest> | undefined): boolean {
    return proto3.util.equals(FileRequest, a, b);
  }
}

/**
 * aiserver.v1.FSGetMultiFileContentsRequest
 *
 * @generated from message aiserver.v1.FSGetMultiFileContentsRequest
 */
export class FSGetMultiFileContentsRequest extends Message<FSGetMultiFileContentsRequest> {
  /**
   * @generated from field: string auth_id = 1;
   */
  authId = "";

  /**
   * @generated from field: repeated aiserver.v1.FilesyncUpdateWithModelVersion filesync_updates = 2;
   */
  filesyncUpdates: FilesyncUpdateWithModelVersion[] = [];

  /**
   * @generated from field: repeated aiserver.v1.FileRequest file_requests = 3;
   */
  fileRequests: FileRequest[] = [];

  /**
   * @generated from field: bool get_all_recent_files = 4;
   */
  getAllRecentFiles = false;

  constructor(data?: PartialMessage<FSGetMultiFileContentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSGetMultiFileContentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auth_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "filesync_updates", kind: "message", T: FilesyncUpdateWithModelVersion, repeated: true },
    { no: 3, name: "file_requests", kind: "message", T: FileRequest, repeated: true },
    { no: 4, name: "get_all_recent_files", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSGetMultiFileContentsRequest {
    return new FSGetMultiFileContentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSGetMultiFileContentsRequest {
    return new FSGetMultiFileContentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSGetMultiFileContentsRequest {
    return new FSGetMultiFileContentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSGetMultiFileContentsRequest | PlainMessage<FSGetMultiFileContentsRequest> | undefined, b: FSGetMultiFileContentsRequest | PlainMessage<FSGetMultiFileContentsRequest> | undefined): boolean {
    return proto3.util.equals(FSGetMultiFileContentsRequest, a, b);
  }
}

/**
 * aiserver.v1.FileRetrieved
 *
 * @generated from message aiserver.v1.FileRetrieved
 */
export class FileRetrieved extends Message<FileRetrieved> {
  /**
   * @generated from field: string relative_workspace_path = 1;
   */
  relativeWorkspacePath = "";

  /**
   * @generated from field: string contents = 2;
   */
  contents = "";

  /**
   * @generated from field: int32 model_version = 3;
   */
  modelVersion = 0;

  /**
   * @generated from field: google.protobuf.Timestamp last_modified = 4;
   */
  lastModified?: Timestamp;

  constructor(data?: PartialMessage<FileRetrieved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FileRetrieved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relative_workspace_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contents", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "model_version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "last_modified", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileRetrieved {
    return new FileRetrieved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileRetrieved {
    return new FileRetrieved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileRetrieved {
    return new FileRetrieved().fromJsonString(jsonString, options);
  }

  static equals(a: FileRetrieved | PlainMessage<FileRetrieved> | undefined, b: FileRetrieved | PlainMessage<FileRetrieved> | undefined): boolean {
    return proto3.util.equals(FileRetrieved, a, b);
  }
}

/**
 * aiserver.v1.FSGetMultiFileContentsResponse
 *
 * @generated from message aiserver.v1.FSGetMultiFileContentsResponse
 */
export class FSGetMultiFileContentsResponse extends Message<FSGetMultiFileContentsResponse> {
  /**
   * @generated from field: repeated aiserver.v1.FileRetrieved files = 1;
   */
  files: FileRetrieved[] = [];

  constructor(data?: PartialMessage<FSGetMultiFileContentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSGetMultiFileContentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "files", kind: "message", T: FileRetrieved, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSGetMultiFileContentsResponse {
    return new FSGetMultiFileContentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSGetMultiFileContentsResponse {
    return new FSGetMultiFileContentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSGetMultiFileContentsResponse {
    return new FSGetMultiFileContentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSGetMultiFileContentsResponse | PlainMessage<FSGetMultiFileContentsResponse> | undefined, b: FSGetMultiFileContentsResponse | PlainMessage<FSGetMultiFileContentsResponse> | undefined): boolean {
    return proto3.util.equals(FSGetMultiFileContentsResponse, a, b);
  }
}

/**
 * aiserver.v1.FSInternalHealthCheckRequest
 *
 * @generated from message aiserver.v1.FSInternalHealthCheckRequest
 */
export class FSInternalHealthCheckRequest extends Message<FSInternalHealthCheckRequest> {
  /**
   * @generated from field: optional bool from_server = 1;
   */
  fromServer?: boolean;

  constructor(data?: PartialMessage<FSInternalHealthCheckRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSInternalHealthCheckRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from_server", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSInternalHealthCheckRequest {
    return new FSInternalHealthCheckRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSInternalHealthCheckRequest {
    return new FSInternalHealthCheckRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSInternalHealthCheckRequest {
    return new FSInternalHealthCheckRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSInternalHealthCheckRequest | PlainMessage<FSInternalHealthCheckRequest> | undefined, b: FSInternalHealthCheckRequest | PlainMessage<FSInternalHealthCheckRequest> | undefined): boolean {
    return proto3.util.equals(FSInternalHealthCheckRequest, a, b);
  }
}

/**
 * aiserver.v1.FSInternalHealthCheckResponse
 *
 * @generated from message aiserver.v1.FSInternalHealthCheckResponse
 */
export class FSInternalHealthCheckResponse extends Message<FSInternalHealthCheckResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  constructor(data?: PartialMessage<FSInternalHealthCheckResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSInternalHealthCheckResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSInternalHealthCheckResponse {
    return new FSInternalHealthCheckResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSInternalHealthCheckResponse {
    return new FSInternalHealthCheckResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSInternalHealthCheckResponse {
    return new FSInternalHealthCheckResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSInternalHealthCheckResponse | PlainMessage<FSInternalHealthCheckResponse> | undefined, b: FSInternalHealthCheckResponse | PlainMessage<FSInternalHealthCheckResponse> | undefined): boolean {
    return proto3.util.equals(FSInternalHealthCheckResponse, a, b);
  }
}

/**
 * aiserver.v1.FSConfigRequest
 *
 * @generated from message aiserver.v1.FSConfigRequest
 */
export class FSConfigRequest extends Message<FSConfigRequest> {
  constructor(data?: PartialMessage<FSConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSConfigRequest {
    return new FSConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSConfigRequest {
    return new FSConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSConfigRequest {
    return new FSConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FSConfigRequest | PlainMessage<FSConfigRequest> | undefined, b: FSConfigRequest | PlainMessage<FSConfigRequest> | undefined): boolean {
    return proto3.util.equals(FSConfigRequest, a, b);
  }
}

/**
 * aiserver.v1.FSConfigResponse
 *
 * @generated from message aiserver.v1.FSConfigResponse
 */
export class FSConfigResponse extends Message<FSConfigResponse> {
  /**
   * @generated from field: float check_filesync_hash_percent = 1;
   */
  checkFilesyncHashPercent = 0;

  /**
   * @generated from field: optional int32 rate_limiter_breaker_reset_time_ms = 2;
   */
  rateLimiterBreakerResetTimeMs?: number;

  /**
   * @generated from field: optional int32 rate_limiter_rps = 3;
   */
  rateLimiterRps?: number;

  /**
   * @generated from field: optional int32 rate_limiter_burst_capacity = 4;
   */
  rateLimiterBurstCapacity?: number;

  /**
   * @generated from field: optional int32 max_recent_updates_stored = 5;
   */
  maxRecentUpdatesStored?: number;

  /**
   * @generated from field: optional int32 max_model_version_cache_size = 6;
   */
  maxModelVersionCacheSize?: number;

  /**
   * @generated from field: optional int32 max_file_size_to_sync_bytes = 7;
   */
  maxFileSizeToSyncBytes?: number;

  /**
   * @generated from field: optional int32 sync_retry_max_attempts = 8;
   */
  syncRetryMaxAttempts?: number;

  /**
   * @generated from field: optional int32 sync_retry_initial_delay_ms = 9;
   */
  syncRetryInitialDelayMs?: number;

  /**
   * @generated from field: optional int32 sync_retry_time_multiplier = 10;
   */
  syncRetryTimeMultiplier?: number;

  /**
   * @generated from field: optional int32 file_sync_status_max_cache_size = 11;
   */
  fileSyncStatusMaxCacheSize?: number;

  /**
   * @generated from field: optional int32 successive_syncs_required_for_reliance = 12;
   */
  successiveSyncsRequiredForReliance?: number;

  /**
   * @generated from field: optional int32 extra_successful_syncs_needed_after_errors = 13;
   */
  extraSuccessfulSyncsNeededAfterErrors?: number;

  /**
   * @generated from field: optional int32 big_change_stripping_threshold_bytes = 14;
   */
  bigChangeStrippingThresholdBytes?: number;

  /**
   * @generated from field: optional int32 last_n_updates_to_send = 15;
   */
  lastNUpdatesToSend?: number;

  /**
   * @generated from field: optional int32 file_sync_status_ttl_ms = 16;
   */
  fileSyncStatusTtlMs?: number;

  /**
   * @generated from field: optional int32 sync_debounce_ms = 17;
   */
  syncDebounceMs?: number;

  /**
   * @generated from field: optional int32 sync_update_threshold = 18;
   */
  syncUpdateThreshold?: number;

  constructor(data?: PartialMessage<FSConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "aiserver.v1.FSConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "check_filesync_hash_percent", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "rate_limiter_breaker_reset_time_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "rate_limiter_rps", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "rate_limiter_burst_capacity", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "max_recent_updates_stored", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 6, name: "max_model_version_cache_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 7, name: "max_file_size_to_sync_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 8, name: "sync_retry_max_attempts", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 9, name: "sync_retry_initial_delay_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 10, name: "sync_retry_time_multiplier", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 11, name: "file_sync_status_max_cache_size", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 12, name: "successive_syncs_required_for_reliance", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 13, name: "extra_successful_syncs_needed_after_errors", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 14, name: "big_change_stripping_threshold_bytes", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 15, name: "last_n_updates_to_send", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 16, name: "file_sync_status_ttl_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 17, name: "sync_debounce_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 18, name: "sync_update_threshold", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FSConfigResponse {
    return new FSConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FSConfigResponse {
    return new FSConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FSConfigResponse {
    return new FSConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FSConfigResponse | PlainMessage<FSConfigResponse> | undefined, b: FSConfigResponse | PlainMessage<FSConfigResponse> | undefined): boolean {
    return proto3.util.equals(FSConfigResponse, a, b);
  }
}

